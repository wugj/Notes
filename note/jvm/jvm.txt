1、jvm组成  内存模型
    a、haap堆区  存储实力对象（线程共享）
    b、方法区  存储加载过的类信息、常量、静态变量（线程共享）
    c、本地方法C  本地方法（非线程共享） 为执行本地方法（Native Method）服务的
    d、jvmC 存储线程局部变量、操作数、动态链接、引用等（非线程共享）
    e、程序计数器 当前线程所执行的字节码的行号指示器（非线程共享）

2、hotSpot虚拟机
    a、对象的创建
           1、先到方法区看看有没有加载过，存储了类的信息，没有的话现加载
           2、通过已经加载过的类信息 来分配内存
           3、分配完内存之后，将该内存初始化为零
           4、对象的基本信息 hash值  对象的gc分代信息等  对象头设置
           5、执行对象init方法初始化
    b、对象的内存布局
           1、对象头 存储对象自身的运行数据如 hash值，gc的分代信息
           2、类型指针 类元素指针 知道是哪个类的实例对象
           3、实例数据  真正的存储的有效数据  变量内容等
           4、对齐填充  不是必然存在
    c、对象的访问定位
           1、句柄形式，在堆区分出一个句柄，C中的引用指向heap中的句柄，然后句柄一部分指向heap中的实例对象，一部分执行方法区中的类数据
           2、指针形式，C中的引用直接指向heap中的对象，对象中一部分指向方法区中的类数据

3、垃圾收集算法
    a、标记清除：先标记可回收内存，再回收内存，不足，效率不高，产生不连续碎片
    b、标记整理清楚：将存活对象移动到一端，然后清楚可回收对象
    c、复制：内存分两块，先使用其中一块，满了再用另一块，分代算法中的年轻代就是用的这个
    d、分代算法
           1、年轻代   新建对象，可以短期回收的，如果几次GC都没有回收就放入老生代
                       年轻代有一个Eden区，两个Survivor（from - to）区，先从eden区复制到survivor区，多次不能GC的进入年老代
           2、老生代 声明周期比较长的
           3、持久代  静态数据之类的
4、垃圾收集器
    a、serial：运行在年轻代用标记复制的方法 暂定全部线程
    b、serial old： 运行在年老代使用标记整理 暂停全部线程
    c、parNew ：serial多线程版本  暂定全部线程
    d、Parallel ：多线程维护一个吞吐量，回收少，次数就多
    e、CMS ： 并发对内存CPU敏感， 标记清楚 产生碎片空间
            1、初始标记：标记GC Roots可达对象，时间段，阻塞线程
            2、并发标记：跟用户线程并发标记可回收对象
            3、重新标记：标记在并发标记是产生的可回收对象，修正并发标记，阻塞线程
            4、并发清理： 使用标记清除算法
    f、G1：标记整理算法  将堆分为多个可大小相等独立区域，跟踪里面的垃圾跟面积，后台维护一个优先表，每次优先回收
            1、初始标记：标记一下GC Roots能直接关联到的对象
            2、并发标记：跟用户线程并发标记可回收对象
            3、同上
            4、筛选回收：根据用户期望的GC停顿时间来制定回收计划

4、Minor GC与Full GC分别在什么时候发生
    Full GC: 年老代（Tenured）被写满
            持久代（Perm）被写满
            System.gc()被显示调用
    Minor GC: 当新对象生成，并且在Eden申请空间失败时,然后对Eden区GC，并把剩余的复制到survivor区并整理

5、GC的判断
        a、引用计数，对象添加引用,计数器+1，引用失效计数器-1，不能结局对象之前循环引用问题
        b、可达性，正对GCRoots可不可达
              1、虚拟机C中的引用对象
              2、方法区静态属性的引用对象
              3、方法区中常量引用对象
              4、本地方法C引用对象


